<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Backend 문서 | 8dobibim Tech Blog</title>
<meta name="keywords" content="">
<meta name="description" content="📘 8dobibim 운영 및 배포 가이드
이 문서는 OpenWebUI 및 LiteLLM 기반으로 백엔드 시스템을 구성하고,
API 프록시 환경 구축, 인프라 자동화, CI/CD 파이프라인 설정, 운영 효율화 등을 다룬 내용을 정리하고 있습니다.
각 섹션을 통해 프로젝트의 방향성과 작업 내용을 한눈에 파악할 수 있으며, 하단의 문서 링크를 통해 세부 작업 내역을 확인할 수 있습니다.

📋 사전 준비

🧾 사전준비사항
🌐 AWS 환경 설정

⚙️ 인프라 설정

📐 Terraform 설정
☸️ EKS 클러스터 배포 가이드

🔁 CI/CD 및 애플리케이션 배포

🚀 CI/CD 파이프라인 가이드라인
📦 애플리케이션 배포 가이드

✅ 배포 검증 및 운영

🧪 배포 검증 가이드
🖥️ 운영 매뉴얼

🛠️ 트러블슈팅

🧯 트러블슈팅 가이드 &amp; FAQ
">
<meta name="author" content="">
<link rel="canonical" href="https://8dobibim.github.io/backend/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://8dobibim.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://8dobibim.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://8dobibim.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://8dobibim.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://8dobibim.github.io/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://8dobibim.github.io/backend/index.xml">
<link rel="alternate" hreflang="en" href="https://8dobibim.github.io/backend/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://8dobibim.github.io/backend/">
  <meta property="og:site_name" content="8dobibim Tech Blog">
  <meta property="og:title" content="Backend 문서">
  <meta property="og:description" content="📘 8dobibim 운영 및 배포 가이드 이 문서는 OpenWebUI 및 LiteLLM 기반으로 백엔드 시스템을 구성하고,
API 프록시 환경 구축, 인프라 자동화, CI/CD 파이프라인 설정, 운영 효율화 등을 다룬 내용을 정리하고 있습니다.
각 섹션을 통해 프로젝트의 방향성과 작업 내용을 한눈에 파악할 수 있으며, 하단의 문서 링크를 통해 세부 작업 내역을 확인할 수 있습니다.
📋 사전 준비 🧾 사전준비사항 🌐 AWS 환경 설정 ⚙️ 인프라 설정 📐 Terraform 설정 ☸️ EKS 클러스터 배포 가이드 🔁 CI/CD 및 애플리케이션 배포 🚀 CI/CD 파이프라인 가이드라인 📦 애플리케이션 배포 가이드 ✅ 배포 검증 및 운영 🧪 배포 검증 가이드 🖥️ 운영 매뉴얼 🛠️ 트러블슈팅 🧯 트러블슈팅 가이드 &amp; FAQ ">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Backend 문서">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Backend 문서",
      "item": "https://8dobibim.github.io/backend/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://8dobibim.github.io/" accesskey="h" title="8dobibim Tech Blog (Alt + H)">8dobibim Tech Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://8dobibim.github.io/frontend/" title="🖥 프론트엔드">
                    <span>🖥 프론트엔드</span>
                </a>
            </li>
            <li>
                <a href="https://8dobibim.github.io/backend/" title="💾 백엔드">
                    <span class="active">💾 백엔드</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://8dobibim.github.io/">Home</a></div>
  <h1>
    Backend 문서
  </h1>
</header>
<div class="post-content"><h1 id="-8dobibim-운영-및-배포-가이드">📘 8dobibim 운영 및 배포 가이드<a hidden class="anchor" aria-hidden="true" href="#-8dobibim-운영-및-배포-가이드">#</a></h1>
<p>이 문서는 <code>OpenWebUI</code> 및 <code>LiteLLM</code> 기반으로 백엔드 시스템을 구성하고,<br>
<strong>API 프록시 환경 구축</strong>, <strong>인프라 자동화</strong>, <strong>CI/CD 파이프라인 설정</strong>, <strong>운영 효율화</strong> 등을 다룬 내용을 정리하고 있습니다.</p>
<p>각 섹션을 통해 프로젝트의 방향성과 작업 내용을 한눈에 파악할 수 있으며, 하단의 문서 링크를 통해 세부 작업 내역을 확인할 수 있습니다.</p>
<hr>
<h3 id="-사전-준비">📋 사전 준비<a hidden class="anchor" aria-hidden="true" href="#-사전-준비">#</a></h3>
<ul>
<li><a href="/backend/%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84%EC%82%AC%ED%95%AD">🧾 사전준비사항</a></li>
<li><a href="/backend/aws-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95">🌐 AWS 환경 설정</a></li>
</ul>
<h3 id="-인프라-설정">⚙️ 인프라 설정<a hidden class="anchor" aria-hidden="true" href="#-인프라-설정">#</a></h3>
<ul>
<li><a href="/backend/terraform-%EC%84%A4%EC%A0%95">📐 Terraform 설정</a></li>
<li><a href="/backend/eks-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EB%B0%B0%ED%8F%AC-%EA%B0%80%EC%9D%B4%EB%93%9C">☸️ EKS 클러스터 배포 가이드</a></li>
</ul>
<h3 id="-cicd-및-애플리케이션-배포">🔁 CI/CD 및 애플리케이션 배포<a hidden class="anchor" aria-hidden="true" href="#-cicd-및-애플리케이션-배포">#</a></h3>
<ul>
<li><a href="/backend/ci_cd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8">🚀 CI/CD 파이프라인 가이드라인</a></li>
<li><a href="/backend/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EB%B0%B0%ED%8F%AC%20%EA%B0%80%EC%9D%B4%EB%93%9C">📦 애플리케이션 배포 가이드</a></li>
</ul>
<h3 id="-배포-검증-및-운영">✅ 배포 검증 및 운영<a hidden class="anchor" aria-hidden="true" href="#-배포-검증-및-운영">#</a></h3>
<ul>
<li><a href="/backend/%EB%B0%B0%ED%8F%AC-%EA%B2%80%EC%A6%9D-%EA%B0%80%EC%9D%B4%EB%93%9C">🧪 배포 검증 가이드</a></li>
<li><a href="/backend/%EC%9A%B4%EC%98%81-%EB%A7%A4%EB%89%B4%EC%96%BC">🖥️ 운영 매뉴얼</a></li>
</ul>
<h3 id="-트러블슈팅">🛠️ 트러블슈팅<a hidden class="anchor" aria-hidden="true" href="#-트러블슈팅">#</a></h3>
<ul>
<li><a href="/backend/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-%EA%B0%80%EC%9D%B4%EB%93%9C--faq">🧯 트러블슈팅 가이드 &amp; FAQ</a></li>
</ul>


</div>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🏗️ AWS 환경 설정 가이드 ⏱️ 예상 소요시간: 약 30-45분 (설계 및 계획)
💡 난이도: 초급-중급
📋 목표: OpenWebUI 배포를 위한 AWS 인프라 설계 및 구성 계획을 수립합니다.
📋 설정 완료 체크리스트 네트워크 아키텍처 설계 완료 리소스 명명 규칙 정의 보안 그룹 계획 수립 EKS 클러스터 구성 계획 비용 계산 및 예산 설정 백업 및 재해 복구 계획 🎯 전체 아키텍처 개요 시스템 구성도 ┌─────────────────────────────────────────────────────────────┐│ AWS Cloud ││ ┌─────────────────────────────────────────────────────────┐││ │ VPC (10.0.0.0/16) │││ │ ┌─────────────────────┐ ┌─────────────────────────────┐│││ │ │ Public Subnet A │ │ Public Subnet B ││││ │ │ (10.0.1.0/24) │ │ (10.0.2.0/24) ││││ │ │ ┌─────────────────┐│ │ ┌─────────────────────────┐││││ │ │ │ NAT Gateway A ││ │ │ NAT Gateway B │││││ │ │ └─────────────────┘│ │ └─────────────────────────┘││││ │ │ ┌─────────────────┐│ │ ┌─────────────────────────┐││││ │ │ │ Internet Gateway││ │ │ Load Balancer │││││ │ │ └─────────────────┘│ │ └─────────────────────────┘││││ │ └─────────────────────┘ └─────────────────────────────┘│││ │ ┌─────────────────────┐ ┌─────────────────────────────┐│││ │ │ Private Subnet A │ │ Private Subnet B ││││ │ │ (10.0.10.0/24) │ │ (10.0.20.0/24) ││││ │ │ ┌─────────────────┐│ │ ┌─────────────────────────┐││││ │ │ │ EKS Node Group A││ │ │ EKS Node Group B │││││ │ │ │ ││ │ │ │││││ │ │ │ OpenWebUI Pods ││ │ │ LiteLLM Pods │││││ │ │ │ Monitoring Pods ││ │ │ Database Pods │││││ │ │ └─────────────────┘│ │ └─────────────────────────┘││││ │ └─────────────────────┘ └─────────────────────────────┘│││ │ │││ │ ┌─────────────────────────────────────────────────────┐│││ │ │ EKS Control Plane │││ │ │ (AWS Managed) │││ │ └─────────────────────────────────────────────────────┘│││ └─────────────────────────────────────────────────────────┘│└─────────────────────────────────────────────────────────────┘외부 연결:- ECR (컨테이너 이미지 저장소)- S3 (Terraform State, 백업)- DynamoDB (Terraform Lock)- CloudWatch (로깅 및 모니터링) 주요 구성 요소 설명 구성 요소 목적 위치 VPC 격리된 네트워크 환경 ap-northeast-2 Public Subnet 인터넷 게이트웨이, 로드밸런서 2개 AZ Private Subnet EKS 워커 노드, 애플리케이션 2개 AZ EKS Cluster Kubernetes 관리형 서비스 Multi-AZ Node Groups EC2 인스턴스 그룹 Private Subnet ALB 애플리케이션 로드밸런서 Public Subnet 🌐 네트워크 설계 VPC 및 서브넷 구성 기본 네트워크 설정 VPC 설정: CIDR: 10.0.0.0/16 Region: ap-northeast-2 (서울) DNS Resolution: Enabled DNS Hostnames: Enabled 가용 영역: - ap-northeast-2a - ap-northeast-2c 서브넷 설계 Public Subnets: Public-A: CIDR: 10.0.1.0/24 AZ: ap-northeast-2a 용도: NAT Gateway, Load Balancer Public-B: CIDR: 10.0.2.0/24 AZ: ap-northeast-2c 용도: NAT Gateway, Load Balancer Private Subnets: Private-A: CIDR: 10.0.10.0/24 AZ: ap-northeast-2a 용도: EKS Worker Nodes Private-B: CIDR: 10.0.20.0/24 AZ: ap-northeast-2c 용도: EKS Worker Nodes 라우팅 테이블 설계 Public Route Table 대상: 0.0.0.0/0 게이트웨이: Internet Gateway 연결된 서브넷: - Public Subnet A - Public Subnet B Private Route Tables Private Route Table A: 대상: 0.0.0.0/0 게이트웨이: NAT Gateway A 연결 서브넷: Private Subnet A Private Route Table B: 대상: 0.0.0.0/0 게이트웨이: NAT Gateway B 연결 서브넷: Private Subnet B 🔒 보안 그룹 설계 EKS 클러스터 보안 그룹 Control Plane Security Group 이름: openwebui-eks-control-plane-sg 설명: EKS Control Plane 보안 그룹 Inbound Rules: - Type: HTTPS Port: 443 Source: Worker Node Security Group 설명: Worker 노드에서 API 서버 접근 Outbound Rules: - Type: All Traffic Port: All Destination: 0.0.0.0/0 설명: 모든 아웃바운드 트래픽 허용 Worker Node Security Group 이름: openwebui-eks-worker-sg 설명: EKS Worker Node 보안 그룹 Inbound Rules: - Type: All Traffic Port: All Source: Same Security Group 설명: 워커 노드간 통신 - Type: Custom TCP Port: 1025-65535 Source: Control Plane Security Group 설명: Control Plane에서 kubelet 통신 - Type: HTTP Port: 80 Source: ALB Security Group 설명: 로드밸런서에서 애플리케이션 접근 - Type: Custom TCP Port: 30000-32767 Source: ALB Security Group 설명: NodePort 서비스 접근 Outbound Rules: - Type: All Traffic Port: All Destination: 0.0.0.0/0 설명: 모든 아웃바운드 트래픽 허용 Application Load Balancer Security Group 이름: openwebui-alb-sg 설명: ALB 보안 그룹 Inbound Rules: - Type: HTTP Port: 80 Source: 0.0.0.0/0 설명: 인터넷에서 HTTP 접근 - Type: HTTPS Port: 443 Source: 0.0.0.0/0 설명: 인터넷에서 HTTPS 접근 Outbound Rules: - Type: Custom TCP Port: 80 Destination: Worker Node Security Group 설명: 워커 노드로 트래픽 전달 - Type: Custom TCP Port: 30000-32767 Destination: Worker Node Security Group 설명: NodePort 서비스 접근 ⚙️ EKS 클러스터 설계 클러스터 기본 설정 클러스터 설정: 이름: openwebui-eks-dev 버전: 1.28 엔드포인트 액세스: Public: true Private: true 로깅: - api - audit - authenticator - controllerManager - scheduler Node Group 설계 Primary Node Group 이름: openwebui-primary-nodes 인스턴스 타입: t3.medium 스케일링: 최소: 2 최대: 4 원하는 용량: 2 디스크: 크기: 20GB 타입: gp3 레이블: environment: dev nodegroup: primary Taints: 없음 Spot Instance Node Group (비용 절약용) 이름: openwebui-spot-nodes 인스턴스 타입: - t3.medium - t3.large - m5.large 구매 옵션: Spot Instance 스케일링: 최소: 0 최대: 3 원하는 용량: 1 레이블: environment: dev nodegroup: spot Taints: - Key: spot Value: &#34;true&#34; Effect: NoSchedule Add-ons 설정 필수 Add-ons: - vpc-cni (네트워킹) - coredns (DNS) - kube-proxy (네트워크 프록시) 추가 Add-ons: - aws-load-balancer-controller - ebs-csi-driver - cluster-autoscaler 🏷️ 리소스 명명 규칙 명명 규칙 표준 형식: {project}-{resource-type}-{environment}-{optional-suffix} 예시: VPC: openwebui-vpc-dev Subnet: openwebui-public-subnet-dev-a Security Group: openwebui-eks-sg-dev EKS Cluster: openwebui-eks-dev Node Group: openwebui-primary-nodes-dev Load Balancer: openwebui-alb-dev 태그 전략 모든 리소스 공통 태그: Project: openwebui Environment: dev Owner: team-name ManagedBy: terraform 리소스별 추가 태그: EKS Cluster: kubernetes.io/cluster/openwebui-eks-dev: owned Subnet: kubernetes.io/role/elb: 1 (public subnet) kubernetes.io/role/internal-elb: 1 (private subnet) 💰 비용 계산 및 최적화 예상 월 비용 (서울 리전 기준) 기본 구성 서비스 스펙 월 예상 비용 설명 EKS Control Plane 관리형 서비스 $72 클러스터당 고정 비용 EC2 인스턴스 2x t3.medium $60 워커 노드 (on-demand) EBS 볼륨 40GB gp3 $4 워커 노드 스토리지 NAT Gateway 2개 AZ $64 각 AZ당 $32 Load Balancer ALB $22 기본 요금 &#43; 트래픽 데이터 전송 예상 10GB $1 아웃바운드 트래픽 기타 서비스 ECR, CloudWatch $5 로그, 이미지 저장 총 예상 비용: 월 $228
...</p>
  </div>
  <footer class="entry-footer">8 min&nbsp;·&nbsp;1606 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/aws-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🚀 AWS EKS CI/CD 파이프라인 구축 가이드 ⏱️ 예상 소요시간: 45-60분
💡 난이도: 중급
📋 목표: GitHub Actions를 사용하여 AWS EKS에 OpenWebUI 애플리케이션을 자동 배포하는 CI/CD 파이프라인 구축
📁 전체 코드: GitHub에서 확인하기
📋 전체 구조 개요 파이프라인 단계별 흐름 1. GitHub Push 트리거2. AWS 인증 및 환경 설정3. Terraform으로 인프라 구축4. EKS 클러스터 설정5. 필수 컴포넌트 설치6. ArgoCD 설치 및 설정7. 애플리케이션 배포8. 헬스체크 및 롤백 🔐 Step 1: GitHub Secrets 및 기본 설정 필요한 Secrets 목록 # GitHub 리포지토리 → Settings → Secrets and variables → Actions # AWS 인증 AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY # API 키들 GEMINI_API_KEY AZURE_API_KEY AZURE_API_BASE AZURE_API_VERSION # 데이터베이스 POSTGRES_DB POSTGRES_USER POSTGRES_PASSWORD DATABASE_URL # LiteLLM LITELLM_MASTER_KEY LITELLM_SALT_KEY 워크플로우 기본 설정 name: Deploy to AWS EKS on: push: branches: - main # main 브랜치에 푸시될 때만 실행 jobs: deploy: runs-on: ubuntu-latest # Ubuntu 최신 버전 사용 env: # Terraform 작업 디렉토리 TF_WORKING_DIR: ./terraform-related/AWS_terraform_grafana # ArgoCD 초기 비밀번호 해시 (admin) ARGOCD_PASSWORD_HASH: $2a$10$8K9jKpK7a9c6xL8zFiZ65uHpYz9ROzAyl3PzGp6u2Fj0CeLccL5tK 🔍 설명:
...</p>
  </div>
  <footer class="entry-footer">8 min&nbsp;·&nbsp;1584 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/ci_cd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>⚙️ EKS 클러스터 배포 가이드 ⏱️ 예상 소요시간: 30-45분
💡 난이도: 중급
📋 목표: Terraform으로 생성된 EKS 클러스터에 필수 컴포넌트를 설치하고 설정합니다.
📋 배포 완료 체크리스트 kubectl 클러스터 연결 설정 AWS Load Balancer Controller 설치 EBS CSI Driver 설정 Cluster Autoscaler 설치 Metrics Server 설치 네임스페이스 생성 RBAC 설정 🔗 1단계: 클러스터 연결 설정 kubectl 설정 # EKS 클러스터에 연결 aws eks update-kubeconfig --region ap-northeast-2 --name openwebui-eks-dev # 클러스터 연결 확인 kubectl cluster-info kubectl get nodes 예상 출력:
...</p>
  </div>
  <footer class="entry-footer">6 min&nbsp;·&nbsp;1106 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/eks-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EB%B0%B0%ED%8F%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🏗️ 실제 프로젝트 기반 Terraform 구성 가이드 ⏱️ 예상 소요시간: 60-90분
💡 난이도: 중급
📋 목표: Terraform을 사용하여 AWS EKS 클러스터와 애플리케이션 스택 구축
📁 전체 코드: GitHub에서 확인하기
📁 프로젝트 구조 terraform-related/└── AWS_terraform_grafana/├── main.tf # 메인 리소스 정의├── variables.tf # 변수 선언├── versions.tf # 프로바이더 버전├── terraform.tfvars # 변수 값 (Git 제외)└── tfvars.example # 변수 예시 파일 🔧 Step 1: 프로바이더 및 버전 설정 versions.tf terraform { required_providers { kubernetes = { source = &#34;hashicorp/kubernetes&#34; version = &#34;2.23.0&#34; } aws = { source = &#34;hashicorp/aws&#34; version = &#34;5.45.0&#34; } } } 🔍 설명:
...</p>
  </div>
  <footer class="entry-footer">10 min&nbsp;·&nbsp;2101 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/terraform-%EC%84%A4%EC%A0%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>✅ 배포 검증 가이드 ⏱️ 예상 소요시간: 30-45분
💡 난이도: 초급-중급
📋 목표: 배포된 OpenWebUI 시스템의 정상 작동을 검증하고 테스트합니다.
📋 검증 완료 체크리스트 인프라 상태 확인 데이터베이스 연결 테스트 LiteLLM API 테스트 OpenWebUI 웹 인터페이스 테스트 로드밸런서 및 네트워킹 테스트 로그 및 모니터링 확인 부하 테스트 실행 장애 복구 테스트 🏗️ 1단계: 인프라 상태 확인 클러스터 전체 상태 #!/bin/bash # infrastructure-check.sh echo &#34;🔍 인프라 상태 검증 시작...&#34; echo &#34;📋 1. 클러스터 노드 상태&#34; kubectl get nodes -o wide echo &#34;📋 2. 네임스페이스 확인&#34; kubectl get namespaces echo &#34;📋 3. 전체 파드 상태&#34; kubectl get pods -A -o wide echo &#34;📋 4. 서비스 상태&#34; kubectl get svc -A echo &#34;📋 5. Ingress 상태&#34; kubectl get ingress -A echo &#34;📋 6. PVC 상태&#34; kubectl get pvc -A echo &#34;📋 7. 시크릿 확인&#34; kubectl get secrets -A echo &#34;✅ 인프라 상태 확인 완료&#34; 리소스 사용량 확인 # 노드 리소스 사용량 kubectl top nodes # 파드 리소스 사용량 kubectl top pods -A # 네임스페이스별 리소스 사용량 kubectl top pods -n openwebui kubectl top pods -n litellm 🗃️ 2단계: 데이터베이스 연결 테스트 PostgreSQL 연결 테스트 # PostgreSQL 파드에 직접 접속 kubectl exec -it deployment/postgres -n openwebui -- psql -U openwebui -d openwebui # SQL 명령어로 테스트 \l # 데이터베이스 목록 \dt # 테이블 목록 SELECT version(); # PostgreSQL 버전 확인 SELECT now(); # 현재 시간 \q # 종료 데이터베이스 연결 스크립트 #!/bin/bash # db-connection-test.sh echo &#34;🗃️ 데이터베이스 연결 테스트...&#34; # PostgreSQL 파드 상태 확인 if ! kubectl get pod -l app=postgres -n openwebui | grep -q &#34;Running&#34;; then echo &#34;❌ PostgreSQL 파드가 실행 중이 아닙니다.&#34; exit 1 fi # 연결 테스트 echo &#34;📡 데이터베이스 연결 테스트 중...&#34; kubectl exec deployment/postgres -n openwebui -- pg_isready -U openwebui if [ $? -eq 0 ]; then echo &#34;✅ PostgreSQL 연결 성공&#34; else echo &#34;❌ PostgreSQL 연결 실패&#34; exit 1 fi # 데이터베이스 쿼리 테스트 echo &#34;🔍 기본 쿼리 테스트...&#34; kubectl exec deployment/postgres -n openwebui -- psql -U openwebui -d openwebui -c &#34;SELECT 1 as test;&#34; echo &#34;✅ 데이터베이스 테스트 완료&#34; 🤖 3단계: LiteLLM API 테스트 LiteLLM 서비스 상태 확인 # LiteLLM 파드 상태 kubectl get pods -l app=litellm -n litellm # LiteLLM 서비스 엔드포인트 확인 kubectl get endpoints -n litellm # LiteLLM 로그 확인 kubectl logs deployment/litellm -n litellm --tail=50 API 엔드포인트 테스트 #!/bin/bash # litellm-api-test.sh echo &#34;🤖 LiteLLM API 테스트...&#34; # 포트 포워딩 설정 kubectl port-forward svc/litellm-service 4000:4000 -n litellm &amp; PORT_FORWARD_PID=$! sleep 5 # Health check echo &#34;📡 헬스체크 테스트...&#34; curl -s http://localhost:4000/health # 모델 목록 확인 echo &#34;📝 모델 목록 확인...&#34; curl -s http://localhost:4000/v1/models | jq &#39;.&#39; # 간단한 채팅 완료 테스트 echo &#34;💬 채팅 완료 API 테스트...&#34; curl -X POST http://localhost:4000/v1/chat/completions \ -H &#34;Content-Type: application/json&#34; \ -H &#34;Authorization: Bearer your-master-key&#34; \ -d &#39;{ &#34;model&#34;: &#34;gpt-3.5-turbo&#34;, &#34;messages&#34;: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Hello, this is a test.&#34;}], &#34;max_tokens&#34;: 50 }&#39; | jq &#39;.&#39; # 포트 포워딩 종료 kill $PORT_FORWARD_PID echo &#34;✅ LiteLLM API 테스트 완료&#34; 🌐 4단계: OpenWebUI 웹 인터페이스 테스트 웹 인터페이스 접근 테스트 #!/bin/bash # webui-access-test.sh echo &#34;🌐 OpenWebUI 접근 테스트...&#34; # OpenWebUI 파드 상태 확인 kubectl get pods -l app=openwebui -n openwebui # 포트 포워딩으로 로컬 접근 테스트 kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; PORT_FORWARD_PID=$! sleep 10 # HTTP 상태 코드 확인 echo &#34;📡 HTTP 상태 확인...&#34; HTTP_STATUS=$(curl -s -o /dev/null -w &#34;%{http_code}&#34; http://localhost:8080) if [ &#34;$HTTP_STATUS&#34; = &#34;200&#34; ]; then echo &#34;✅ OpenWebUI 접근 성공 (HTTP $HTTP_STATUS)&#34; else echo &#34;❌ OpenWebUI 접근 실패 (HTTP $HTTP_STATUS)&#34; fi # HTML 응답 확인 echo &#34;📄 HTML 응답 확인...&#34; curl -s http://localhost:8080 | head -20 # 포트 포워딩 종료 kill $PORT_FORWARD_PID echo &#34;✅ OpenWebUI 접근 테스트 완료&#34; 브라우저 테스트 체크리스트 수동 테스트 항목:□ 메인 페이지 로딩□ 회원가입 페이지□ 로그인 기능□ 채팅 인터페이스□ 모델 선택 기능□ 파일 업로드 기능□ 설정 페이지 접근 🌍 5단계: 로드밸런서 및 네트워킹 테스트 Ingress/LoadBalancer 상태 확인 #!/bin/bash # networking-test.sh echo &#34;🌍 네트워킹 테스트...&#34; # Ingress 상태 확인 echo &#34;📡 Ingress 상태:&#34; kubectl get ingress -n openwebui -o wide # LoadBalancer 상태 확인 echo &#34;⚖️ LoadBalancer 상태:&#34; kubectl get svc -n openwebui -o wide # DNS 해상도 테스트 echo &#34;🔍 DNS 해상도 테스트:&#34; INGRESS_HOST=$(kubectl get ingress openwebui-ingress -n openwebui -o jsonpath=&#39;{.status.loadBalancer.ingress[0].hostname}&#39;) if [ -n &#34;$INGRESS_HOST&#34; ]; then echo &#34;Ingress 호스트: $INGRESS_HOST&#34; nslookup $INGRESS_HOST # HTTP 테스트 echo &#34;🔗 외부 접근 테스트:&#34; curl -I http://$INGRESS_HOST --connect-timeout 10 else echo &#34;⚠️ Ingress 호스트를 찾을 수 없습니다.&#34; fi echo &#34;✅ 네트워킹 테스트 완료&#34; 서비스 간 통신 테스트 #!/bin/bash # service-communication-test.sh echo &#34;🔄 서비스 간 통신 테스트...&#34; # OpenWebUI에서 LiteLLM 연결 테스트 echo &#34;📡 OpenWebUI → LiteLLM 연결 테스트:&#34; kubectl exec deployment/openwebui -n openwebui -- \ curl -s http://litellm-service.litellm.svc.cluster.local:4000/health # OpenWebUI에서 PostgreSQL 연결 테스트 echo &#34;🗃️ OpenWebUI → PostgreSQL 연결 테스트:&#34; kubectl exec deployment/openwebui -n openwebui -- \ nc -zv postgres-service 5432 # LiteLLM에서 PostgreSQL 연결 테스트 echo &#34;🗃️ LiteLLM → PostgreSQL 연결 테스트:&#34; kubectl exec deployment/litellm -n litellm -- \ nc -zv postgres-service.openwebui.svc.cluster.local 5432 echo &#34;✅ 서비스 간 통신 테스트 완료&#34; 📊 6단계: 로그 및 모니터링 확인 애플리케이션 로그 확인 #!/bin/bash # log-check.sh echo &#34;📊 로그 확인...&#34; echo &#34;🗃️ PostgreSQL 로그:&#34; kubectl logs deployment/postgres -n openwebui --tail=20 echo &#34;🤖 LiteLLM 로그:&#34; kubectl logs deployment/litellm -n litellm --tail=20 echo &#34;🌐 OpenWebUI 로그:&#34; kubectl logs deployment/openwebui -n openwebui --tail=20 # 에러 로그 검색 echo &#34;❌ 에러 로그 검색:&#34; kubectl logs deployment/openwebui -n openwebui | grep -i error | tail -10 kubectl logs deployment/litellm -n litellm | grep -i error | tail -10 echo &#34;✅ 로그 확인 완료&#34; 이벤트 확인 # 클러스터 이벤트 확인 kubectl get events -A --sort-by=&#39;.lastTimestamp&#39; | tail -20 # 네임스페이스별 이벤트 kubectl get events -n openwebui --sort-by=&#39;.lastTimestamp&#39; kubectl get events -n litellm --sort-by=&#39;.lastTimestamp&#39; 메트릭 확인 # 리소스 사용량 모니터링 kubectl top pods -n openwebui --containers kubectl top pods -n litellm --containers # 파드별 상세 메트릭 kubectl describe pod -l app=openwebui -n openwebui kubectl describe pod -l app=litellm -n litellm 🚀 7단계: 부하 테스트 간단한 부하 테스트 #!/bin/bash # load-test.sh echo &#34;🚀 부하 테스트 시작...&#34; # 포트 포워딩 설정 kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; PORT_FORWARD_PID=$! sleep 5 # Apache Bench를 사용한 부하 테스트 echo &#34;⚡ HTTP 부하 테스트 (100 요청, 동시접속 10):&#34; ab -n 100 -c 10 http://localhost:8080/ # curl을 사용한 반복 테스트 echo &#34;🔄 반복 접속 테스트:&#34; for i in {1..10}; do echo &#34;요청 $i:&#34; curl -s -o /dev/null -w &#34;HTTP Status: %{http_code}, Time: %{time_total}s\n&#34; http://localhost:8080/ sleep 1 done # 포트 포워딩 종료 kill $PORT_FORWARD_PID echo &#34;✅ 부하 테스트 완료&#34; K6를 사용한 고급 부하 테스트 // k6-load-test.js import http from &#39;k6/http&#39;; import { check, sleep } from &#39;k6&#39;; export let options = { stages: [ { duration: &#39;2m&#39;, target: 10 }, // 2분간 10명 사용자로 증가 { duration: &#39;5m&#39;, target: 10 }, // 5분간 10명 사용자 유지 { duration: &#39;2m&#39;, target: 20 }, // 2분간 20명 사용자로 증가 { duration: &#39;5m&#39;, target: 20 }, // 5분간 20명 사용자 유지 { duration: &#39;2m&#39;, target: 0 }, // 2분간 0명으로 감소 ], }; export default function () { let response = http.get(&#39;http://localhost:8080&#39;); check(response, { &#39;status is 200&#39;: (r) =&gt; r.status === 200, &#39;response time &lt; 500ms&#39;: (r) =&gt; r.timings.duration &lt; 500, }); sleep(1); } # K6 설치 및 실행 # 1. K6 설치 (macOS) brew install k6 # 2. 부하 테스트 실행 kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; k6 run k6-load-test.js 🔧 8단계: 장애 복구 테스트 파드 장애 시뮬레이션 #!/bin/bash # failure-recovery-test.sh echo &#34;🔧 장애 복구 테스트...&#34; echo &#34;💥 OpenWebUI 파드 삭제 (장애 시뮬레이션):&#34; kubectl delete pod -l app=openwebui -n openwebui echo &#34;⏳ 파드 재생성 대기 (30초):&#34; sleep 30 echo &#34;✅ 파드 복구 상태 확인:&#34; kubectl get pods -l app=openwebui -n openwebui echo &#34;🔍 서비스 가용성 테스트:&#34; kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; PORT_FORWARD_PID=$! sleep 10 HTTP_STATUS=$(curl -s -o /dev/null -w &#34;%{http_code}&#34; http://localhost:8080) echo &#34;HTTP 상태: $HTTP_STATUS&#34; kill $PORT_FORWARD_PID if [ &#34;$HTTP_STATUS&#34; = &#34;200&#34; ]; then echo &#34;✅ 장애 복구 성공&#34; else echo &#34;❌ 장애 복구 실패&#34; fi echo &#34;✅ 장애 복구 테스트 완료&#34; 데이터베이스 장애 테스트 #!/bin/bash # db-failure-test.sh echo &#34;🗃️ 데이터베이스 장애 테스트...&#34; echo &#34;💥 PostgreSQL 파드 삭제:&#34; kubectl delete pod -l app=postgres -n openwebui echo &#34;⏳ 파드 재생성 및 데이터 복구 대기 (60초):&#34; sleep 60 echo &#34;✅ PostgreSQL 복구 확인:&#34; kubectl wait --for=condition=ready pod -l app=postgres -n openwebui --timeout=300s echo &#34;🔍 데이터 무결성 확인:&#34; kubectl exec deployment/postgres -n openwebui -- psql -U openwebui -d openwebui -c &#34;SELECT 1 as test;&#34; echo &#34;✅ 데이터베이스 장애 테스트 완료&#34; 📈 9단계: 성능 벤치마크 애플리케이션 성능 측정 #!/bin/bash # performance-benchmark.sh echo &#34;📈 성능 벤치마크 시작...&#34; # 포트 포워딩 설정 kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; PORT_FORWARD_PID=$! sleep 5 echo &#34;⏱️ 응답 시간 측정 (10회):&#34; for i in {1..10}; do curl -s -o /dev/null -w &#34;응답시간 $i: %{time_total}s\n&#34; http://localhost:8080/ done echo &#34;📊 동시 접속 테스트:&#34; ab -n 50 -c 5 http://localhost:8080/ | grep -E &#34;(Requests per second|Time per request)&#34; # 포트 포워딩 종료 kill $PORT_FORWARD_PID echo &#34;💾 리소스 사용량 기록:&#34; kubectl top pods -n openwebui --containers kubectl top pods -n litellm --containers echo &#34;✅ 성능 벤치마크 완료&#34; 🔍 10단계: 종합 검증 리포트 자동 검증 스크립트 #!/bin/bash # comprehensive-verification.sh set -e REPORT_FILE=&#34;verification-report-$(date &#43;%Y%m%d-%H%M%S).txt&#34; echo &#34;📋 OpenWebUI 종합 검증 리포트&#34; | tee $REPORT_FILE echo &#34;생성 시간: $(date)&#34; | tee -a $REPORT_FILE echo &#34;======================================&#34; | tee -a $REPORT_FILE # 1. 인프라 상태 echo &#34;🏗️ 1. 인프라 상태&#34; | tee -a $REPORT_FILE kubectl get nodes --no-headers | wc -l | xargs echo &#34;- 활성 노드 수:&#34; | tee -a $REPORT_FILE kubectl get pods -A --field-selector=status.phase=Running --no-headers | wc -l | xargs echo &#34;- 실행 중인 파드:&#34; | tee -a $REPORT_FILE # 2. 애플리케이션 상태 echo &#34;🌐 2. 애플리케이션 상태&#34; | tee -a $REPORT_FILE kubectl get pods -n openwebui -l app=openwebui --no-headers | grep Running | wc -l | xargs echo &#34;- OpenWebUI 파드:&#34; | tee -a $REPORT_FILE kubectl get pods -n litellm -l app=litellm --no-headers | grep Running | wc -l | xargs echo &#34;- LiteLLM 파드:&#34; | tee -a $REPORT_FILE kubectl get pods -n openwebui -l app=postgres --no-headers | grep Running | wc -l | xargs echo &#34;- PostgreSQL 파드:&#34; | tee -a $REPORT_FILE # 3. 서비스 연결성 echo &#34;🔗 3. 서비스 연결성&#34; | tee -a $REPORT_FILE if kubectl exec deployment/openwebui -n openwebui -- curl -s http://litellm-service.litellm.svc.cluster.local:4000/health &gt; /dev/null; then echo &#34;- OpenWebUI → LiteLLM: ✅&#34; | tee -a $REPORT_FILE else echo &#34;- OpenWebUI → LiteLLM: ❌&#34; | tee -a $REPORT_FILE fi if kubectl exec deployment/postgres -n openwebui -- pg_isready &gt; /dev/null; then echo &#34;- PostgreSQL 연결: ✅&#34; | tee -a $REPORT_FILE else echo &#34;- PostgreSQL 연결: ❌&#34; | tee -a $REPORT_FILE fi # 4. 외부 접근성 echo &#34;🌍 4. 외부 접근성&#34; | tee -a $REPORT_FILE kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui &amp; PORT_FORWARD_PID=$! sleep 5 HTTP_STATUS=$(curl -s -o /dev/null -w &#34;%{http_code}&#34; http://localhost:8080 || echo &#34;000&#34;) if [ &#34;$HTTP_STATUS&#34; = &#34;200&#34; ]; then echo &#34;- HTTP 접근: ✅ ($HTTP_STATUS)&#34; | tee -a $REPORT_FILE else echo &#34;- HTTP 접근: ❌ ($HTTP_STATUS)&#34; | tee -a $REPORT_FILE fi kill $PORT_FORWARD_PID # 5. 리소스 사용량 echo &#34;📊 5. 리소스 사용량&#34; | tee -a $REPORT_FILE kubectl top nodes --no-headers | awk &#39;{print &#34;- 노드 &#34; $1 &#34;: CPU &#34; $3 &#34;, Memory &#34; $5}&#39; | tee -a $REPORT_FILE # 6. 최근 에러 로그 echo &#34;❌ 6. 최근 에러 (최근 10분)&#34; | tee -a $REPORT_FILE ERROR_COUNT=$(kubectl logs --since=10m -l app=openwebui -n openwebui | grep -i error | wc -l) echo &#34;- OpenWebUI 에러: $ERROR_COUNT 건&#34; | tee -a $REPORT_FILE echo &#34;======================================&#34; | tee -a $REPORT_FILE echo &#34;✅ 검증 완료 - 리포트 파일: $REPORT_FILE&#34; | tee -a $REPORT_FILE 검증 체크리스트 확인 #!/bin/bash # final-checklist.sh echo &#34;📋 최종 배포 검증 체크리스트&#34; echo &#34;===============================&#34; checks=( &#34;모든 파드가 Running 상태인가?&#34; &#34;데이터베이스 연결이 정상인가?&#34; &#34;LiteLLM API가 응답하는가?&#34; &#34;OpenWebUI 웹 페이지가 로드되는가?&#34; &#34;외부에서 접근 가능한가?&#34; &#34;파드 간 통신이 정상인가?&#34; &#34;로그에 심각한 에러가 없는가?&#34; &#34;리소스 사용량이 적정한가?&#34; &#34;장애 복구가 정상 작동하는가?&#34; &#34;성능이 요구사항을 만족하는가?&#34; ) for check in &#34;${checks[@]}&#34;; do echo &#34;□ $check&#34; done echo &#34;&#34; echo &#34;모든 항목이 체크되면 배포가 성공적으로 완료된 것입니다! 🎉&#34; 🚨 문제 해결 가이드 일반적인 문제들 1. 파드가 Pending 상태 # 원인 확인 kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt; # 일반적인 해결책 # - 노드 리소스 부족: 스케일링 또는 리소스 조정 # - PVC 마운트 실패: StorageClass 확인 # - 이미지 Pull 실패: 이미지 레지스트리 접근 권한 확인 2. 서비스 연결 실패 # 서비스 엔드포인트 확인 kubectl get endpoints -n &lt;namespace&gt; # DNS 해상도 테스트 kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- nslookup &lt;service-name&gt; # 네트워크 정책 확인 kubectl get networkpolicy -A 3. 로드밸런서 접근 불가 # ALB 상태 확인 kubectl describe ingress &lt;ingress-name&gt; -n &lt;namespace&gt; # AWS 콘솔에서 로드밸런서 상태 확인 aws elbv2 describe-load-balancers # 보안 그룹 규칙 확인 aws ec2 describe-security-groups 📚 성능 최적화 권장사항 리소스 최적화 # 권장 리소스 설정 resources: requests: memory: &#34;256Mi&#34; cpu: &#34;250m&#34; limits: memory: &#34;512Mi&#34; cpu: &#34;500m&#34; 캐싱 전략 Redis 캐시 추가 고려 CDN 설정 (정적 자원용) 데이터베이스 쿼리 최적화 모니터링 강화 Prometheus &#43; Grafana 설치 Alert Manager 설정 로그 집계 시스템 구축 ⏭️ 다음 단계 배포 검증이 완료되었다면:
...</p>
  </div>
  <footer class="entry-footer">11 min&nbsp;·&nbsp;2135 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/%EB%B0%B0%ED%8F%AC-%EA%B2%80%EC%A6%9D-%EA%B0%80%EC%9D%B4%EB%93%9C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🚀 OpenWebUI AWS 배포 사전 준비사항 ⏱️ 예상 소요시간: 약 60-90분
💡 난이도: 초급
📋 목표: AWS에 OpenWebUI를 배포하기 위한 모든 도구와 환경을 준비합니다.
📋 준비 완료 체크리스트 작업을 시작하기 전에 아래 항목들을 체크해주세요:
필수 계정 AWS 계정 (결제 정보 등록 완료) GitHub 계정 Docker Hub 계정 (선택사항) 필수 도구 설치 AWS CLI v2 Terraform v1.5&#43; kubectl v1.24&#43; Docker Desktop Git 코드 에디터 (VS Code 권장) 권한 및 설정 AWS IAM 사용자 생성 및 권한 설정 AWS CLI 자격 증명 설정 GitHub Personal Access Token 생성 1️⃣ AWS 계정 및 IAM 설정 AWS 계정 준비 AWS 계정이 없는 경우
...</p>
  </div>
  <footer class="entry-footer">6 min&nbsp;·&nbsp;1243 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84%EC%82%AC%ED%95%AD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🚀 애플리케이션 배포 가이드 ⏱️ 예상 소요시간: 45-60분
💡 난이도: 중급
📋 목표: EKS 클러스터에 OpenWebUI와 LiteLLM을 배포합니다.
📋 배포 완료 체크리스트 ConfigMap 및 Secret 생성 PostgreSQL 데이터베이스 배포 LiteLLM 서비스 배포 OpenWebUI 애플리케이션 배포 Ingress/LoadBalancer 설정 SSL 인증서 설정 모니터링 설정 📁 배포 파일 구조 kubernetes/├── base/│ ├── configmaps/│ ├── secrets/│ ├── postgres/│ ├── litellm/│ ├── openwebui/│ └── ingress/└── overlays/├── dev/└── prod/ 🗂️ 1단계: ConfigMap 및 Secret 생성 ConfigMap 생성 # kubernetes/base/configmaps/app-config.yaml apiVersion: v1 kind: ConfigMap metadata: name: app-config namespace: openwebui data: # PostgreSQL 설정 POSTGRES_HOST: &#34;postgres-service.openwebui.svc.cluster.local&#34; POSTGRES_PORT: &#34;5432&#34; POSTGRES_DB: &#34;openwebui&#34; # LiteLLM 설정 LITELLM_HOST: &#34;litellm-service.litellm.svc.cluster.local&#34; LITELLM_PORT: &#34;4000&#34; # OpenWebUI 설정 WEBUI_SECRET_KEY: &#34;your-secret-key-here&#34; WEBUI_JWT_SECRET_KEY: &#34;your-jwt-secret-here&#34; DEFAULT_LOCALE: &#34;ko-KR&#34; # 기본 설정 LOG_LEVEL: &#34;INFO&#34; ENVIRONMENT: &#34;development&#34; --- apiVersion: v1 kind: ConfigMap metadata: name: litellm-config namespace: litellm data: config.yaml: | model_list: - model_name: gpt-3.5-turbo litellm_params: model: gpt-3.5-turbo api_key: os.environ/OPENAI_API_KEY - model_name: gpt-4 litellm_params: model: gpt-4 api_key: os.environ/OPENAI_API_KEY - model_name: claude-3-sonnet litellm_params: model: anthropic/claude-3-sonnet-20240229 api_key: os.environ/ANTHROPIC_API_KEY general_settings: master_key: os.environ/LITELLM_MASTER_KEY database_url: os.environ/DATABASE_URL Secret 생성 # kubernetes/base/secrets/app-secrets.yaml apiVersion: v1 kind: Secret metadata: name: app-secrets namespace: openwebui type: Opaque data: # Base64로 인코딩된 값들 POSTGRES_USER: b3BlbndlYnVp # openwebui POSTGRES_PASSWORD: cGFzc3dvcmQxMjM= # password123 --- apiVersion: v1 kind: Secret metadata: name: api-keys namespace: litellm type: Opaque data: OPENAI_API_KEY: eW91ci1vcGVuYWktYXBpLWtleQ== # your-openai-api-key ANTHROPIC_API_KEY: eW91ci1hbnRocm9waWMtYXBpLWtleQ== # your-anthropic-api-key LITELLM_MASTER_KEY: bGl0ZWxsbS1tYXN0ZXIta2V5 # litellm-master-key 실제 Secret 생성 (명령어) # PostgreSQL 인증 정보 kubectl create secret generic app-secrets \ --from-literal=POSTGRES_USER=openwebui \ --from-literal=POSTGRES_PASSWORD=password123 \ -n openwebui # API 키들 kubectl create secret generic api-keys \ --from-literal=OPENAI_API_KEY=your-actual-openai-key \ --from-literal=ANTHROPIC_API_KEY=your-actual-anthropic-key \ --from-literal=LITELLM_MASTER_KEY=your-master-key \ -n litellm 🗃️ 2단계: PostgreSQL 데이터베이스 배포 PVC 생성 # kubernetes/base/postgres/pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: postgres-pvc namespace: openwebui spec: accessModes: - ReadWriteOnce storageClassName: gp3-encrypted resources: requests: storage: 10Gi PostgreSQL Deployment # kubernetes/base/postgres/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: postgres namespace: openwebui spec: replicas: 1 selector: matchLabels: app: postgres template: metadata: labels: app: postgres spec: containers: - name: postgres image: postgres:15 ports: - containerPort: 5432 env: - name: POSTGRES_DB valueFrom: configMapKeyRef: name: app-config key: POSTGRES_DB - name: POSTGRES_USER valueFrom: secretKeyRef: name: app-secrets key: POSTGRES_USER - name: POSTGRES_PASSWORD valueFrom: secretKeyRef: name: app-secrets key: POSTGRES_PASSWORD - name: PGDATA value: /var/lib/postgresql/data/pgdata volumeMounts: - name: postgres-storage mountPath: /var/lib/postgresql/data resources: requests: memory: &#34;256Mi&#34; cpu: &#34;250m&#34; limits: memory: &#34;512Mi&#34; cpu: &#34;500m&#34; volumes: - name: postgres-storage persistentVolumeClaim: claimName: postgres-pvc PostgreSQL Service # kubernetes/base/postgres/service.yaml apiVersion: v1 kind: Service metadata: name: postgres-service namespace: openwebui spec: selector: app: postgres ports: - port: 5432 targetPort: 5432 type: ClusterIP 🤖 3단계: LiteLLM 서비스 배포 LiteLLM Deployment # kubernetes/base/litellm/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: litellm namespace: litellm spec: replicas: 2 selector: matchLabels: app: litellm template: metadata: labels: app: litellm spec: containers: - name: litellm image: ghcr.io/berriai/litellm:main-latest ports: - containerPort: 4000 env: - name: OPENAI_API_KEY valueFrom: secretKeyRef: name: api-keys key: OPENAI_API_KEY - name: ANTHROPIC_API_KEY valueFrom: secretKeyRef: name: api-keys key: ANTHROPIC_API_KEY - name: LITELLM_MASTER_KEY valueFrom: secretKeyRef: name: api-keys key: LITELLM_MASTER_KEY - name: DATABASE_URL value: &#34;postgresql://$(POSTGRES_USER):$(POSTGRES_PASSWORD)@postgres-service.openwebui.svc.cluster.local:5432/litellm&#34; envFrom: - secretRef: name: app-secrets volumeMounts: - name: config mountPath: /app/config.yaml subPath: config.yaml command: [&#34;litellm&#34;, &#34;--config&#34;, &#34;/app/config.yaml&#34;, &#34;--port&#34;, &#34;4000&#34;, &#34;--num_workers&#34;, &#34;8&#34;] resources: requests: memory: &#34;512Mi&#34; cpu: &#34;250m&#34; limits: memory: &#34;1Gi&#34; cpu: &#34;500m&#34; readinessProbe: httpGet: path: /health/readiness port: 4000 initialDelaySeconds: 30 periodSeconds: 10 livenessProbe: httpGet: path: /health/liveliness port: 4000 initialDelaySeconds: 60 periodSeconds: 30 volumes: - name: config configMap: name: litellm-config LiteLLM Service # kubernetes/base/litellm/service.yaml apiVersion: v1 kind: Service metadata: name: litellm-service namespace: litellm spec: selector: app: litellm ports: - port: 4000 targetPort: 4000 type: ClusterIP 🌐 4단계: OpenWebUI 애플리케이션 배포 OpenWebUI Deployment # kubernetes/base/openwebui/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: openwebui namespace: openwebui spec: replicas: 2 selector: matchLabels: app: openwebui template: metadata: labels: app: openwebui spec: containers: - name: openwebui image: ghcr.io/open-webui/open-webui:main ports: - containerPort: 8080 env: - name: OLLAMA_BASE_URL value: &#34;http://litellm-service.litellm.svc.cluster.local:4000&#34; - name: WEBUI_SECRET_KEY valueFrom: configMapKeyRef: name: app-config key: WEBUI_SECRET_KEY - name: DATABASE_URL value: &#34;postgresql://$(POSTGRES_USER):$(POSTGRES_PASSWORD)@postgres-service:5432/openwebui&#34; - name: DEFAULT_LOCALE valueFrom: configMapKeyRef: name: app-config key: DEFAULT_LOCALE envFrom: - secretRef: name: app-secrets - configMapRef: name: app-config volumeMounts: - name: data mountPath: /app/backend/data resources: requests: memory: &#34;512Mi&#34; cpu: &#34;250m&#34; limits: memory: &#34;1Gi&#34; cpu: &#34;500m&#34; readinessProbe: httpGet: path: /health port: 8080 initialDelaySeconds: 30 periodSeconds: 10 livenessProbe: httpGet: path: /health port: 8080 initialDelaySeconds: 60 periodSeconds: 30 volumes: - name: data persistentVolumeClaim: claimName: openwebui-pvc OpenWebUI PVC # kubernetes/base/openwebui/pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: openwebui-pvc namespace: openwebui spec: accessModes: - ReadWriteOnce storageClassName: gp3-encrypted resources: requests: storage: 5Gi OpenWebUI Service # kubernetes/base/openwebui/service.yaml apiVersion: v1 kind: Service metadata: name: openwebui-service namespace: openwebui spec: selector: app: openwebui ports: - port: 8080 targetPort: 8080 type: ClusterIP 🌍 5단계: Ingress 및 LoadBalancer 설정 Application Load Balancer (ALB) 설정 # kubernetes/base/ingress/ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: openwebui-ingress namespace: openwebui annotations: # ALB 설정 kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip # SSL 설정 alb.ingress.kubernetes.io/listen-ports: &#39;[{&#34;HTTP&#34;: 80}, {&#34;HTTPS&#34;: 443}]&#39; alb.ingress.kubernetes.io/ssl-redirect: &#39;443&#39; alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-northeast-2:ACCOUNT_ID:certificate/CERT_ID # 헬스체크 설정 alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/healthcheck-interval-seconds: &#39;30&#39; alb.ingress.kubernetes.io/healthcheck-timeout-seconds: &#39;5&#39; alb.ingress.kubernetes.io/healthy-threshold-count: &#39;2&#39; alb.ingress.kubernetes.io/unhealthy-threshold-count: &#39;3&#39; # 기타 설정 alb.ingress.kubernetes.io/load-balancer-name: openwebui-alb alb.ingress.kubernetes.io/tags: Environment=dev,Project=openwebui spec: rules: - host: openwebui.yourdomain.com http: paths: - path: / pathType: Prefix backend: service: name: openwebui-service port: number: 8080 LoadBalancer Service (대안) # kubernetes/base/ingress/loadbalancer.yaml apiVersion: v1 kind: Service metadata: name: openwebui-loadbalancer namespace: openwebui annotations: service.beta.kubernetes.io/aws-load-balancer-type: &#34;nlb&#34; service.beta.kubernetes.io/aws-load-balancer-scheme: &#34;internet-facing&#34; service.beta.kubernetes.io/aws-load-balancer-name: &#34;openwebui-nlb&#34; spec: type: LoadBalancer selector: app: openwebui ports: - port: 80 targetPort: 8080 protocol: TCP 📊 6단계: 모니터링 설정 Prometheus ServiceMonitor # kubernetes/base/monitoring/servicemonitor.yaml apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: openwebui-monitor namespace: monitoring spec: selector: matchLabels: app: openwebui endpoints: - port: http path: /metrics interval: 30s --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: litellm-monitor namespace: monitoring spec: selector: matchLabels: app: litellm endpoints: - port: http path: /metrics interval: 30s 🚀 7단계: 배포 실행 배포 순서 # 1. 네임스페이스 생성 (이미 완료됨) kubectl get namespaces # 2. ConfigMap 및 Secret 적용 kubectl apply -f kubernetes/base/configmaps/ kubectl apply -f kubernetes/base/secrets/ # 3. PostgreSQL 배포 kubectl apply -f kubernetes/base/postgres/ # PostgreSQL 준비 완료 대기 kubectl wait --for=condition=ready pod -l app=postgres -n openwebui --timeout=300s # 4. LiteLLM 배포 kubectl apply -f kubernetes/base/litellm/ # LiteLLM 준비 완료 대기 kubectl wait --for=condition=ready pod -l app=litellm -n litellm --timeout=300s # 5. OpenWebUI 배포 kubectl apply -f kubernetes/base/openwebui/ # OpenWebUI 준비 완료 대기 kubectl wait --for=condition=ready pod -l app=openwebui -n openwebui --timeout=300s # 6. Ingress 설정 kubectl apply -f kubernetes/base/ingress/ # 7. 모니터링 설정 (선택사항) kubectl apply -f kubernetes/base/monitoring/ 배포 스크립트 #!/bin/bash # deploy.sh set -e echo &#34;🚀 OpenWebUI 애플리케이션 배포 시작...&#34; # 환경 확인 if ! kubectl get nodes &gt; /dev/null 2&gt;&amp;1; then echo &#34;❌ kubectl이 클러스터에 연결되지 않았습니다.&#34; exit 1 fi echo &#34;📁 1. ConfigMap 및 Secret 적용...&#34; kubectl apply -f kubernetes/base/configmaps/ kubectl apply -f kubernetes/base/secrets/ echo &#34;🗃️ 2. PostgreSQL 배포...&#34; kubectl apply -f kubernetes/base/postgres/ echo &#34;⏳ PostgreSQL 준비 대기...&#34; kubectl wait --for=condition=ready pod -l app=postgres -n openwebui --timeout=300s echo &#34;🤖 3. LiteLLM 배포...&#34; kubectl apply -f kubernetes/base/litellm/ echo &#34;⏳ LiteLLM 준비 대기...&#34; kubectl wait --for=condition=ready pod -l app=litellm -n litellm --timeout=300s echo &#34;🌐 4. OpenWebUI 배포...&#34; kubectl apply -f kubernetes/base/openwebui/ echo &#34;⏳ OpenWebUI 준비 대기...&#34; kubectl wait --for=condition=ready pod -l app=openwebui -n openwebui --timeout=300s echo &#34;🌍 5. Ingress 설정...&#34; kubectl apply -f kubernetes/base/ingress/ echo &#34;📊 6. 모니터링 설정...&#34; kubectl apply -f kubernetes/base/monitoring/ || echo &#34;⚠️ 모니터링 설정 실패 (선택사항)&#34; echo &#34;✅ 배포 완료!&#34; echo &#34;🔗 LoadBalancer URL 확인:&#34; kubectl get ingress -n openwebui kubectl get svc -n openwebui echo &#34;📋 파드 상태 확인:&#34; kubectl get pods -n openwebui kubectl get pods -n litellm chmod &#43;x deploy.sh ./deploy.sh 🔍 상태 확인 배포 상태 확인 # 전체 파드 상태 kubectl get pods -A # 서비스 상태 kubectl get svc -A # Ingress 상태 kubectl get ingress -A # 로그 확인 kubectl logs -f deployment/openwebui -n openwebui kubectl logs -f deployment/litellm -n litellm kubectl logs -f deployment/postgres -n openwebui 서비스 접근 테스트 # 포트 포워딩으로 로컬 테스트 kubectl port-forward svc/openwebui-service 8080:8080 -n openwebui # 브라우저에서 http://localhost:8080 접속 🔧 설정 업데이트 ConfigMap 업데이트 # ConfigMap 수정 후 파드 재시작 kubectl apply -f kubernetes/base/configmaps/ kubectl rollout restart deployment/openwebui -n openwebui kubectl rollout restart deployment/litellm -n litellm Secret 업데이트 # 새 API 키 추가 kubectl create secret generic api-keys \ --from-literal=OPENAI_API_KEY=new-key \ --from-literal=ANTHROPIC_API_KEY=new-key \ --dry-run=client -o yaml | kubectl apply -f - kubectl rollout restart deployment/litellm -n litellm 📈 스케일링 수동 스케일링 # OpenWebUI 파드 개수 조정 kubectl scale deployment openwebui --replicas=3 -n openwebui # LiteLLM 파드 개수 조정 kubectl scale deployment litellm --replicas=4 -n litellm HPA (Horizontal Pod Autoscaler) 설정 # kubernetes/base/openwebui/hpa.yaml apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: openwebui-hpa namespace: openwebui spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: openwebui minReplicas: 2 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: memory target: type: Utilization averageUtilization: 80 ⏭️ 다음 단계 애플리케이션 배포가 완료되었다면:
...</p>
  </div>
  <footer class="entry-footer">7 min&nbsp;·&nbsp;1413 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B0%B0%ED%8F%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🛠️ OpenWebUI 운영 매뉴얼 👥 대상: DevOps 엔지니어, SRE, 시스템 관리자
📅 업데이트: 정기적으로 업데이트 필요
🚨 비상 연락처: [팀 연락처 정보]
📋 일일 운영 체크리스트 매일 확인 항목 #!/bin/bash # daily-check.sh echo &#34;📅 $(date &#39;&#43;%Y-%m-%d %H:%M:%S&#39;) - 일일 운영 체크 시작&#34; # 1. 클러스터 상태 kubectl get nodes kubectl get pods -A | grep -v Running # 2. 애플리케이션 상태 kubectl get pods -n openwebui -n litellm # 3. 리소스 사용량 kubectl top nodes kubectl top pods -A # 4. 최근 에러 로그 (최근 1시간) kubectl logs --since=1h -n openwebui -l app=openwebui | grep -i error | tail -10 # 5. 디스크 사용량 kubectl get pvc -A echo &#34;✅ 일일 체크 완료&#34; 주간 확인 항목 백업 상태 확인 보안 패치 검토 비용 사용량 확인 성능 메트릭 검토 로그 정리 🔍 모니터링 및 알람 핵심 메트릭 # prometheus-alerts.yml groups: - name: openwebui.rules rules: # 파드 상태 알람 - alert: PodCrashLooping expr: rate(kube_pod_container_status_restarts_total[5m]) &gt; 0 for: 5m annotations: summary: &#34;Pod {{ $labels.pod }} is crash looping&#34; # 리소스 사용량 알람 - alert: HighCPUUsage expr: (cpu_usage_rate &gt; 80) for: 10m annotations: summary: &#34;High CPU usage: {{ $value }}%&#34; # 응답 시간 알람 - alert: HighResponseTime expr: http_request_duration_seconds &gt; 2 for: 5m annotations: summary: &#34;High response time: {{ $value }}s&#34; 로그 모니터링 # 실시간 로그 모니터링 kubectl logs -f deployment/openwebui -n openwebui # 에러 로그 검색 kubectl logs deployment/openwebui -n openwebui | grep -E &#34;(ERROR|FATAL|CRITICAL)&#34; # 특정 시간대 로그 kubectl logs --since=2h --until=1h deployment/openwebui -n openwebui 📊 성능 관리 스케일링 관리 # 수동 스케일링 kubectl scale deployment openwebui --replicas=5 -n openwebui kubectl scale deployment litellm --replicas=3 -n litellm # HPA 상태 확인 kubectl get hpa -A # 스케일링 이벤트 확인 kubectl describe hpa openwebui-hpa -n openwebui 리소스 최적화 # 리소스 요청량 조정 예시 resources: requests: memory: &#34;512Mi&#34; # 실제 사용량 기반 조정 cpu: &#34;250m&#34; limits: memory: &#34;1Gi&#34; # OOM 방지 cpu: &#34;500m&#34; # CPU 스로틀링 방지 데이터베이스 성능 # PostgreSQL 연결 수 확인 kubectl exec deployment/postgres -n openwebui -- \ psql -U openwebui -d openwebui -c \ &#34;SELECT count(*) FROM pg_stat_activity WHERE state = &#39;active&#39;;&#34; # 슬로우 쿼리 확인 kubectl exec deployment/postgres -n openwebui -- \ psql -U openwebui -d openwebui -c \ &#34;SELECT query, mean_exec_time FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;&#34; # 데이터베이스 크기 확인 kubectl exec deployment/postgres -n openwebui -- \ psql -U openwebui -d openwebui -c \ &#34;SELECT pg_size_pretty(pg_database_size(&#39;openwebui&#39;));&#34; 🔄 백업 및 복원 데이터베이스 백업 #!/bin/bash # backup-database.sh BACKUP_DATE=$(date &#43;%Y%m%d_%H%M%S) BACKUP_FILE=&#34;openwebui_backup_${BACKUP_DATE}.sql&#34; # PostgreSQL 백업 kubectl exec deployment/postgres -n openwebui -- \ pg_dump -U openwebui openwebui &gt; $BACKUP_FILE # S3에 업로드 aws s3 cp $BACKUP_FILE s3://openwebui-backups/database/ # 로컬 파일 정리 (7일 이상 된 파일) find . -name &#34;openwebui_backup_*.sql&#34; -mtime &#43;7 -delete echo &#34;✅ 백업 완료: $BACKUP_FILE&#34; 데이터베이스 복원 #!/bin/bash # restore-database.sh BACKUP_FILE=$1 if [ -z &#34;$BACKUP_FILE&#34; ]; then echo &#34;사용법: $0 &lt;backup_file&gt;&#34; exit 1 fi # S3에서 백업 파일 다운로드 aws s3 cp s3://openwebui-backups/database/$BACKUP_FILE . # 애플리케이션 중지 kubectl scale deployment openwebui --replicas=0 -n openwebui kubectl scale deployment litellm --replicas=0 -n litellm # 데이터베이스 복원 kubectl exec -i deployment/postgres -n openwebui -- \ psql -U openwebui openwebui &lt; $BACKUP_FILE # 애플리케이션 재시작 kubectl scale deployment openwebui --replicas=2 -n openwebui kubectl scale deployment litellm --replicas=2 -n litellm echo &#34;✅ 복원 완료&#34; 설정 파일 백업 # ConfigMap 백업 kubectl get configmap -n openwebui -o yaml &gt; configmaps-backup.yaml kubectl get configmap -n litellm -o yaml &gt;&gt; configmaps-backup.yaml # Secret 백업 (암호화된 형태) kubectl get secret -n openwebui -o yaml &gt; secrets-backup.yaml kubectl get secret -n litellm -o yaml &gt;&gt; secrets-backup.yaml 🚨 장애 대응 긴급 상황 대응 절차 1단계: 상황 파악 (5분 이내) # 전체 상태 빠른 확인 kubectl get pods -A | grep -v Running kubectl get nodes kubectl top nodes # 최근 이벤트 확인 kubectl get events -A --sort-by=&#39;.lastTimestamp&#39; | tail -20 2단계: 임시 조치 (10분 이내) # 파드 재시작 kubectl rollout restart deployment/openwebui -n openwebui # 트래픽 차단 (필요시) kubectl patch ingress openwebui-ingress -n openwebui -p \ &#39;{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;nginx.ingress.kubernetes.io/server-snippet&#34;:&#34;return 503;&#34;}}}&#39; # 스케일 다운 (리소스 부족 시) kubectl scale deployment openwebui --replicas=1 -n openwebui 3단계: 근본 원인 분석 # 상세 로그 분석 kubectl logs deployment/openwebui -n openwebui --previous kubectl describe pod -l app=openwebui -n openwebui # 리소스 사용량 분석 kubectl top pods -n openwebui --containers kubectl describe nodes 일반적인 장애 시나리오 파드가 시작되지 않는 경우 # 원인 확인 kubectl describe pod &lt;pod-name&gt; -n openwebui # 일반적인 해결책 # 1. 이미지 문제 kubectl get pods -n openwebui -o jsonpath=&#39;{.items[*].spec.containers[*].image}&#39; # 2. 리소스 부족 kubectl describe nodes | grep -A 5 &#34;Allocated resources&#34; # 3. PVC 마운트 실패 kubectl get pvc -n openwebui kubectl describe pvc &lt;pvc-name&gt; -n openwebui 데이터베이스 연결 실패 # PostgreSQL 상태 확인 kubectl get pods -l app=postgres -n openwebui kubectl logs deployment/postgres -n openwebui # 연결 테스트 kubectl exec deployment/postgres -n openwebui -- pg_isready # 네트워크 연결 확인 kubectl exec deployment/openwebui -n openwebui -- \ nc -zv postgres-service 5432 높은 응답 시간 # 리소스 사용량 확인 kubectl top pods -n openwebui # HPA 스케일링 강제 실행 kubectl patch hpa openwebui-hpa -n openwebui -p \ &#39;{&#34;spec&#34;:{&#34;minReplicas&#34;:3}}&#39; # 캐시 클리어 (애플리케이션별 방법) kubectl exec deployment/openwebui -n openwebui -- \ curl -X POST http://localhost:8080/api/v1/cache/clear 🔧 유지보수 정기 업데이트 #!/bin/bash # update-system.sh echo &#34;🔄 시스템 업데이트 시작...&#34; # 1. EKS 클러스터 업데이트 확인 aws eks describe-cluster --name openwebui-eks-dev \ --query &#39;cluster.version&#39; --output text # 2. 노드 그룹 업데이트 확인 aws eks describe-nodegroup --cluster-name openwebui-eks-dev \ --nodegroup-name primary-nodes \ --query &#39;nodegroup.version&#39; --output text # 3. Add-on 업데이트 kubectl get pods -n kube-system # 4. 애플리케이션 이미지 업데이트 kubectl set image deployment/openwebui openwebui=ghcr.io/openwebui:latest -n openwebui echo &#34;✅ 업데이트 완료&#34; 보안 패치 # 보안 스캔 실행 trivy image ghcr.io/openwebui:latest # 취약점 있는 컨테이너 재배포 kubectl rollout restart deployment/openwebui -n openwebui # 시크릿 로테이션 kubectl create secret generic api-keys \ --from-literal=OPENAI_API_KEY=new-key \ --dry-run=client -o yaml | kubectl apply -f - 용량 관리 # 디스크 사용량 모니터링 kubectl get pvc -A -o custom-columns=NAME:.metadata.name,SIZE:.spec.resources.requests.storage,USED:.status.capacity.storage # 로그 정리 kubectl logs deployment/openwebui -n openwebui --tail=1000 &gt; /dev/null # 이미지 정리 (노드에서 직접) docker system prune -a 📈 성능 튜닝 애플리케이션 최적화 # OpenWebUI 성능 설정 env: - name: WEBUI_SECRET_KEY value: &#34;optimized-secret-key&#34; - name: MAX_WORKERS value: &#34;4&#34; - name: TIMEOUT value: &#34;60&#34; - name: KEEP_ALIVE value: &#34;2&#34; 데이터베이스 튜닝 -- PostgreSQL 성능 튜닝 -- 연결 풀 설정 ALTER SYSTEM SET max_connections = 100; ALTER SYSTEM SET shared_buffers = &#39;256MB&#39;; ALTER SYSTEM SET effective_cache_size = &#39;1GB&#39;; ALTER SYSTEM SET work_mem = &#39;4MB&#39;; -- 인덱스 확인 및 최적화 SELECT schemaname, tablename, attname, n_distinct, correlation FROM pg_stats WHERE tablename = &#39;your_table&#39;; 네트워크 최적화 # Ingress 설정 최적화 annotations: nginx.ingress.kubernetes.io/proxy-connect-timeout: &#34;60&#34; nginx.ingress.kubernetes.io/proxy-send-timeout: &#34;60&#34; nginx.ingress.kubernetes.io/proxy-read-timeout: &#34;60&#34; nginx.ingress.kubernetes.io/proxy-body-size: &#34;50m&#34; nginx.ingress.kubernetes.io/enable-cors: &#34;true&#34; 💰 비용 최적화 리소스 사용량 분석 # 노드 비용 분석 kubectl describe nodes | grep -A 3 &#34;Allocated resources&#34; # Spot 인스턴스 활용률 kubectl get nodes -l node.kubernetes.io/instance-type # 사용하지 않는 리소스 정리 kubectl get pods -A --field-selector=status.phase=Succeeded kubectl delete pods --field-selector=status.phase=Succeeded -A 자동 스케일링 최적화 # 비용 효율적인 HPA 설정 spec: minReplicas: 1 # 최소 비용 maxReplicas: 10 # 트래픽 대응 targetCPUUtilizationPercentage: 70 # 적절한 활용률 behavior: scaleDown: stabilizationWindowSeconds: 300 # 급격한 스케일 다운 방지 policies: - type: Percent value: 50 periodSeconds: 60 📞 비상 연락 체계 장애 등급별 대응 P0 (Critical): - 서비스 완전 중단 - 즉시 대응 (24/7) - 연락처: [긴급 연락처] P1 (High): - 주요 기능 장애 - 4시간 이내 대응 - 연락처: [팀 리더] P2 (Medium): - 부분 기능 장애 - 24시간 이내 대응 - 연락처: [담당자] P3 (Low): - 성능 저하 - 72시간 이내 대응 - 연락처: [팀 메일] 에스컬레이션 절차 1차 담당자 (30분 이내 응답) 팀 리더 (1시간 이내) 기술 책임자 (2시간 이내) CTO (4시간 이내) 📚 운영 도구 및 대시보드 필수 도구 # kubectl 플러그인 설치 kubectl krew install ctx ns stern top # 유용한 명령어 별칭 alias k=&#39;kubectl&#39; alias kgp=&#39;kubectl get pods&#39; alias kgs=&#39;kubectl get svc&#39; alias kgn=&#39;kubectl get nodes&#39; alias kdp=&#39;kubectl describe pod&#39; alias kl=&#39;kubectl logs&#39; 모니터링 대시보드 Grafana: http://grafana.your-domain.com Prometheus: http://prometheus.your-domain.com Jaeger: http://jaeger.your-domain.com (트레이싱) ArgoCD: http://argocd.your-domain.com (GitOps) 로그 분석 # 중앙화된 로깅 (ELK Stack) kubectl port-forward svc/kibana 5601:5601 -n logging # 로그 쿼리 예시 # Kibana에서: kubernetes.namespace:&#34;openwebui&#34; AND level:&#34;ERROR&#34; 🔄 정기 작업 스케줄 일일 작업 (자동화) # CronJob 예시 apiVersion: batch/v1 kind: CronJob metadata: name: daily-cleanup spec: schedule: &#34;0 2 * * *&#34; # 매일 오전 2시 jobTemplate: spec: template: spec: containers: - name: cleanup image: alpine:latest command: - /bin/sh - -c - | # 로그 정리 find /var/log -name &#34;*.log&#34; -mtime &#43;7 -delete # 임시 파일 정리 find /tmp -mtime &#43;1 -delete restartPolicy: OnFailure 주간 작업 백업 검증 테스트 보안 스캔 실행 성능 리포트 작성 비용 분석 리포트 월간 작업 DR(재해복구) 테스트 보안 감사 용량 계획 검토 아키텍처 리뷰 이제 완전한 운영 매뉴얼이 준비되었습니다! 🛠️
...</p>
  </div>
  <footer class="entry-footer">7 min&nbsp;·&nbsp;1419 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/%EC%9A%B4%EC%98%81-%EB%A9%94%EB%89%B4%EC%96%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>🚨 트러블슈팅 가이드 &amp; FAQ 🔍 빠른 문제 진단 1단계: 기본 상태 확인 (30초) # 한 번에 전체 상태 확인 kubectl get nodes,pods -A | grep -E &#34;(NotReady|Error|CrashLoop|Pending)&#34; # 최근 이벤트 확인 kubectl get events -A --sort-by=&#39;.lastTimestamp&#39; | tail -10 2단계: 애플리케이션별 상태 (1분) # OpenWebUI 상태 kubectl get pods -n openwebui -o wide # LiteLLM 상태 kubectl get pods -n litellm -o wide # 데이터베이스 상태 kubectl get pods -n openwebui -l app=postgres 3단계: 리소스 사용량 (30초) # 노드 리소스 kubectl top nodes # 파드 리소스 kubectl top pods -A --sort-by=cpu 🔧 인프라 관련 문제 ❌ 노드가 NotReady 상태 증상:
...</p>
  </div>
  <footer class="entry-footer">10 min&nbsp;·&nbsp;2035 words</footer>
  <a class="entry-link" aria-label="post link to " href="https://8dobibim.github.io/backend/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-%EA%B0%80%EC%9D%B4%EB%93%9C--faq/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://8dobibim.github.io/">8dobibim Tech Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
